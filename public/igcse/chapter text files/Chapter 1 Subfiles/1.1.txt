1.1 Number systems

Big idea: computers only see ON/OFF states, so we map all data to number systems that suit the hardware and humans.

Binary (base 2)
- Question: Why do computers prefer binary? Because millions of tiny switches (transistors) are either OFF (0) or ON (1), making binary reliable for storage and processing.
- Key term: bit = single 0/1; nibble = 4 bits; byte = 8 bits.
- How place values work: 128 64 32 16 8 4 2 1; add the positions where the bit is 1.
- Example decode: 10110101 = 128 + 32 + 16 + 4 + 1 = 181.
- Denary → binary (subtractive place values): write the place values; check if each fits the remaining number; e.g., 156 → 128 fits (1), 64 no (0), 32 no (0), 16 yes (1), 8 yes (1), 4 yes (1), 2 no (0), 1 no (0) → 10011100.
- Clarify: more bits double the range each time (n bits → 0 to 2^n – 1 for unsigned).

Hexadecimal (base 16)
- Why use hex? It is shorter for humans and maps exactly to binary nibbles (1 hex digit = 4 bits).
- Digit map: 0–9 then A=10, B=11, C=12, D=13, E=14, F=15.
- Denary → hex: divide by 16; quotient gives the first digit, remainder maps to second digit. Example: 94 ÷ 16 = 5 r14 → 5E.
- Hex → denary: expand with 16s place values. Example: 3C = (3 × 16) + (12 × 1) = 60.
- Real-world sightings: MAC addresses, colour codes (#3FA7D6), error codes (0x…).

Binary addition and overflow
- Line up bits; add column by column; 1+1 = 0 carry 1. Carries propagate left.
- Overflow: if a carry leaves the fixed bit-width (e.g., out of bit 8 on an 8-bit adder), the true sum needs another bit.

Logical shifts (unsigned)
- Left shift by 1 multiplies by 2; right shift by 1 divides by 2 (truncates). Bits shifted out are lost; zeros fill the gaps.
- Example: 00110101 <<1 = 01101010 (53 → 106); 10110000 >>2 = 00101100 (176 → 44).

Two’s complement (signed integers)
- Purpose: represent negative numbers while using the same adder hardware.
- Range (8-bit): -128 to +127; MSB 1 means negative.
- Make a negative: write the positive in binary, invert bits, add 1. Example: -25 → +25 = 00011001 → invert 11100110 → add 1 = 11100111.
- Clarify: only one zero exists because inversion + 1 never returns all 1s.

Common misconceptions to challenge
- “Left shift divides by 2” (it multiplies); “Right shift keeps remainders” (it truncates).
- “After 9 in hex comes 10” (it is A, then B–F).
- “Two’s complement makes -25 by flipping and subtracting 1” (you add 1 after inversion).
